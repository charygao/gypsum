#!/usr/bin/env python2.7
# -*- mode: python; -*-

# Copyright 2014-2015, Jay Conrod. All rights reserved.
#
# This file is part of Gypsum. Use of this source code is governed by
# the GPL license that can be found in the LICENSE.txt file.


import argparse
import os
import os.path
import re
import sys

from ast import AstPackage
from location import NoLoc
from ids import AstId, TARGET_PACKAGE_ID
from ir import Package, PackageVersion, PackageDependency, Name
from lexer import *
from layout import layout
from parser import *
from scope_analysis import *
from type_analysis import *
from externalization import externalize
from compiler import compile
from serialize import serialize
from package_loader import PackageLoader
from compile_info import CompileInfo
from errors import CompileException

sys.setrecursionlimit(10000)

PackageName = lambda s: Name.fromString(s, isPackageName=True)
cmdline = argparse.ArgumentParser(description="Compile source files into CodeSwitch packages")
cmdline.add_argument("sources", metavar="source", type=str, nargs="+",
                     help="Source file names")
cmdline.add_argument("-p", "--package-name", action="store", type=PackageName,
                     default=PackageName("default"),
                     help="Name of the package being compiled")
cmdline.add_argument("-v", "--package-version", action="store", type=PackageVersion.fromString,
                     default=PackageVersion([0]),
                     help="Version of the package being compiled")
cmdline.add_argument("-d", "--depends", action="append", type=PackageDependency.fromString,
                     default=[],
                     help="Additional package dependencies")
cmdline.add_argument("--no-std", action="store_true",
                     help="Do not add a dependency on the standard library")
cmdline.add_argument("-P", "--package-path", action="append", type=str, default=[],
                     help="Directories containing packages that could be imported")
cmdline.add_argument("-o", "--output", action="store",
                     default="out.csp",
                     help="Name of the output file")
cmdline.add_argument("--print-tokens", action="store_true",
                     help="Print raw tokens after lexical analysis")
cmdline.add_argument("--no-layout", action="store_true",
                     help="Disable layout analysis")
cmdline.add_argument("--print-layout", action="store_true",
                     help="Print layout tokens after layout analysis")
cmdline.add_argument("--print-ast", action="store_true",
                     help="Print abstract syntax tree after syntax analysis")
cmdline.add_argument("--print-scope", action="store_true",
                     help="Print scope info after scope analysis")
cmdline.add_argument("--print-types", action="store_true",
                     help="Print types after type analysis")
cmdline.add_argument("--print-ir", action="store_true",
                     help="Print intermediate representation after compilation")
cmdline.add_argument("--print-stack", action="store_true",
                     help="Print compiler stack on error")
args = cmdline.parse_args()

loader = PackageLoader(args.package_path if len(args.package_path) > 0 else None)

try:
    astModules = []
    for sourceFileName in args.sources:
        with open(sourceFileName) as inFile:
            source = inFile.read()
        rawTokens = lex(sourceFileName, source)
        if args.print_tokens:
            for tok in rawTokens:
                sys.stdout.write(str(tok) + "\n")
        if args.no_layout:
            layoutTokens = filter(lambda tok: tok.tag not in [NEWLINE, SPACE, COMMENT], rawTokens)
        else:
            layoutTokens = layout(rawTokens)
        if args.print_layout:
            for tok in layoutTokens:
                sys.stdout.write(str(tok) + "\n")
        ast = parse(sourceFileName, layoutTokens)
        if args.print_ast:
            printer = AstPrinter(sys.stdout)
            printer.visit(ast)
        astModules.append(ast)
    astPackage = AstPackage(astModules, NoLoc)
    astPackage.id = AstId(-1)

    package = Package(TARGET_PACKAGE_ID, args.package_name, args.package_version)
    package.dependencies.extend(args.depends)
    if not args.no_std:
        package.dependencies.append(PackageDependency.fromString("std:1"))
    info = CompileInfo(astPackage, package, loader)

    analyzeDeclarations(info)
    analyzeInheritance(info)
    if args.print_scope:
        sys.stderr.write("--print-scope not supported right now")
    analyzeTypes(info)
    if args.print_types:
        sys.stderr.write("--print-types not supported right now")
    convertClosures(info)
    flattenClasses(info)
    externalize(info)
    compile(info)

    package = info.package
    if args.print_ir:
        sys.stdout.write("%s\n" % str(package))
    serialize(package, args.output)

except (CompileException, IOError) as err:
    if args.print_stack:
        raise
    if isinstance(err, CompileException):
        sys.stderr.write("%s\n" % str(err))
    else:
        sys.stderr.write("%s: error: %s\n" % (sourceFileName, str(err)))
    sys.exit(1)

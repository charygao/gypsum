// Copyright 2016, Jay Conrod. All rights reserved.
//
// This file is part of the Gypsum standard library. Use of this
// source code is governed by the 3-clause BSD license that can be
// found in the LICENSE.txt file.

public def string-to-code-points(str: String): I32Array =
  let n = str.length
  let code-points-mut = new(n) I32Array()
  var i = 0i32
  while (i < n)
    code-points-mut.set(i, str.get(i))
    i += 1i32
  code-points-mut


public def code-points-to-string(code-points: I32Array): String =
  String.from-code-points(code-points)


public def utf8-to-code-points(utf8: I8Array): I32Array =
  // Count code points
  var code-point-count = 0i32
  var byte-index = 0i32
  while (byte-index < utf8.length)
    code-point-count += 1i32
    byte-index += utf8-code-point-length(utf8, byte-index)
    if (byte-index > utf8.length)
      throw IllegalArgumentException()

  // Allocate and fill the array in a second pass.
  let code-points = new(code-point-count) I32Array()
  byte-index = 0i32
  var code-point-index = 0i32
  while (byte-index < utf8.length)
    let cp = utf8-code-point-at(utf8, byte-index)
    code-points.set(code-point-index, cp)
    code-point-index += 1i32
    byte-index += utf8-code-point-length(utf8, byte-index)
  code-points


public def code-points-to-utf8(code-points: I32Array): I8Array =
  // Count bytes needed.
  var utf8-byte-count = 0i64
  var code-point-index = 0i32
  while (code-point-index < code-points.length)
    utf8-byte-count += code-point-utf8-length(code-points.get(code-point-index)).to-i64
    code-point-index += 1i32
  if (utf8-byte-count != utf8-byte-count.to-i32.to-i64)
    throw IllegalArgumentException()   // length overflow

  // Allocate and fill the array in a second pass.
  let utf8-bytes = new(utf8-byte-count.to-i32) I8Array()
  var byte-index = 0i32
  code-point-index = 0i32
  while (code-point-index < code-points.length)
    let cp = code-points.get(code-point-index)
    code-point-to-utf8(cp, utf8-bytes, byte-index)
    byte-index += code-point-utf8-length(cp)
    code-point-index += 1i32
  utf8-bytes


public def string-to-utf8(str: String): I8Array =
  code-points-to-utf8(string-to-code-points(str))


public def utf8-to-string(utf8: I8Array): String =
  code-points-to-string(utf8-to-code-points(utf8))


def utf8-code-point-length(utf8: I8Array, index: i32): i32 =
  let first = utf8.get(index)
  if ((first & 0b10000000i8) == 0i8)
    1i32
  else if ((first & 0b11100000i8) == 0b11000000i8)
    2i32
  else if ((first & 0b11110000i8) == 0b11100000i8)
    3i32
  else if ((first & 0b11111000i8) == 0b11110000i8)
    4i32
  else if ((first & 0b11111100i8) == 0b11111000i8)
    5i32
  else if ((first & 0b11111110i8) == 0b11111100i8)
    6i32
  else
    throw IllegalArgumentException()


def utf8-code-point-at(utf8: I8Array, index: i32): i32 =
  let first = utf8.get(index)
  let n = utf8-code-point-length(utf8, index)
  let first-bit-count = if (n == 1i32) 7i8 else 8i8 - n.to-i8 - 1i8
  var code-point = (first & ((1i8 << first-bit-count) - 1i8)).to-i32
  var i = 1i32
  while (i < n)
    let next = utf8.get(index + i)
    if ((next & 0b11000000i8) != 0b10000000i8)
      throw IllegalArgumentException()
    code-point = (code-point << 6i32) | (next & 0b00111111i8).to-i32
  code-point


def code-point-utf8-length(code-point: i32): i32 =
  if (code-point < 0i32)
    throw IllegalArgumentException()
  else if (code-point < 0x80i32)
    1i32
  else if (code-point < 0x800i32)
    2i32
  else if (code-point < 0x10000i32)
    3i32
  else if (code-point < 0x200000i32)
    4i32
  else if (code-point < 0x4000000i32)
    5i32
  else
    6i32


def code-point-to-utf8(code-point: i32, utf8-bytes: I8Array, index: i32): unit =
  var first-bits: i8
  var rest-count: i32
  if (code-point < 0i32)
    throw IllegalArgumentException()
  else if (code-point < 0x80i32)
    first-bits = 0i8
    rest-count = 0i32
  else if (code-point < 0x800i32)
    first-bits = 0b11000000i8
    rest-count = 1i32
  else if (code-point < 0x10000i32)
    first-bits = 0b11100000i8
    rest-count = 2i32
  else if (code-point < 0x200000i32)
    first-bits = 0b11110000i8
    rest-count = 3i32
  else if (code-point < 0x4000000i32)
    first-bits = 0b11111000i8
    rest-count = 4i32
  else
    first-bits = 0b11111100i8
    rest-count = 5i32

  var shift = rest-count * 6i32
  let first = first-bits | (code-point >> shift).to-i8
  utf8-bytes.set(index, first)
  var i = 1i32
  while (i < rest-count)
    shift -= 6i32
    let next = 0x80i8 | (code-point >> shift).to-i8
    utf8-bytes.set(index + i, next)
    i += 1i32
